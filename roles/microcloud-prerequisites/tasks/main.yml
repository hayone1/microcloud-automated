---
# Add further tasks for the common role (applied to all servers) to this playbook...

- name: Gather the package facts
  package_facts:
    manager: auto
- name: Set index based on inventory hostname
  set_fact:
    index: "{{ ansible_play_hosts.index(inventory_hostname) | int }}"
# - name: Print the package facts
#   ansible.builtin.debug:
#     var: ansible_facts.packages
#   # tags: ["prerequisite"]
# - name: Show interface
#   debug:
#     msg: "{{ ansible_facts['mcbr_bridge'] }}"
    # msg: "{{ hostvars[host]['ansible_facts']['eth0']['ipv4']['address'] }}"
# - name: Show interfaces
#   debug:
#     msg: "{{ ansible_interfaces }}"

# - name: Get loaded modules
#   register: loaded_modules
#   command: lsmod

###### Uncomment this
# - name: Update package lists
#   apt: update_cache=yes
  # tags: ["prerequisite"]

- name: Install snapd package
  when: "'snapd' not in ansible_facts.packages"
  apt:
    name: snapd
    state: present
  # tags: ["prerequisite"]

- name: Install core snap
  when: "'snapd' not in ansible_facts.packages"
  snap:
    name: core
    state: present
  # tags: ["prerequisite"]

- name: Install bridge-utils
  when: "'bridge-utils' not in ansible_facts.packages"
  apt:
    name: bridge-utils
    state: present
    # update_cache: yes

- name: Install net-tools
  when: "'net-tools' not in ansible_facts.packages"
  apt:
    name: net-tools
    state: present
    # update_cache: yes

- name: Install install network-manager
  when: "'network-manager' not in ansible_facts.packages"
  apt:
    name: network-manager
    state: present

- name: Create interface bridge {{ lookup_bridge }}
  when:
    - >-
      vars["ansible_" + lookup_bridge] is not defined
      or vars["ansible_" + lookup_bridge].active != true
  command: brctl addbr {{ lookup_bridge }}
  args:
    creates: /sys/class/net/{{ lookup_bridge }}

# # - name: Set default FORWARD policy to DROP in ebtables
# #   command: ebtables -P FORWARD DROP

- name: >-
    Set firewall rule to DROP packets in
    FORWARD chain(ebtables replacement)
  when: 
    - >-
      vars["ansible_" + lookup_bridge] is not defined
      or vars["ansible_" + lookup_bridge].active != true
  iptables:
    chain: FORWARD
    jump: DROP

- name: Assign IP address to {{ lookup_bridge }} interface bridge
  when: 
    - >-
      vars["ansible_" + lookup_bridge] is not defined
      or vars["ansible_" + lookup_bridge].ipv4.address is undefined
  command: >-
    ip addr add
    {{ lookup_subnet | ansible.utils.next_nth_usable(index | int + 1) }}/{{ bridge_netmask }}
    dev {{ lookup_bridge }}
  # command: echo bridge details - {{vars["ansible_" + lookup_bridge]}}
  vars:
    index: '{{ansible_play_hosts.index(inventory_hostname)}}'
    # bridge_ip: "{{ lookup_subnet | ansible.utils.next_nth_usable(index) }}"
    bridge_netmask: "{{ lookup_subnet | ansible.utils.ipaddr('prefix')}}"

- name: Bring {{ lookup_bridge }} interface bridge up
  when:
    - vars["ansible_" + lookup_bridge] is not defined
      or vars["ansible_" + lookup_bridge].active != true
  command: ip link set dev {{ lookup_bridge }} up

# - name: Create gretap tunnels (all-to-all)
#   nmcli:
#     type: gre
#     conn_name: "{{ iface_name }}"
#     ifname: "{{ iface_name }}"
#     ip_tunnel_dev: "{{ lookup_bridge }}"
#     ip_tunnel_local: "{{ ipv4_address_private }}"
#     ip_tunnel_remote: "{{ hostvars[item]['ipv4_address_private'] }}"
#     state: present

- name: Create gretap tunnels (all-to-all)
  command: |-
    ip link add {{ iface_name }} type gretap local {{ ipv4_address_private }} remote {{ hostvars[item]['ipv4_address_private'] }}
  vars:
    iface_name: gretap_{{ index_key }}_{{ hostvars[item]['index_key'] }}
  args:
    creates: /sys/class/net/{{ iface_name }}
  loop: "{{ groups[ansible_limit] }}"
  when: >-
    vars["ansible_" + iface_name] is not defined
    and inventory_hostname != item
  register: gretap_result

# - name: Debug gretap creation results
#   debug:
#     msg: "Created gretap tunnel: {{ gretap_result }}"
  # when: gretap_result.changed

- name: Bring gretap tunnel up
  command: ip link set dev {{ iface_name }} up
  vars:
    iface_name: gretap_{{ index_key }}_{{ hostvars[item]['index_key'] }}
  loop: "{{ groups[ansible_limit] }}"
  when: >-
    (vars["ansible_" + iface_name] is not defined
    or vars["ansible_" + iface_name].active != true)
    and inventory_hostname != item

- name: Check if gretap tunnels have already been bridged.
  shell: ip link show {{ iface_name }} | grep "master {{ lookup_bridge }}"
  vars:
    iface_name: gretap_{{ index_key }}_{{ hostvars[item]['index_key'] }}
  loop: "{{ groups[ansible_limit] }}"
  when: inventory_hostname != item
  register: gretap_bridged

- name: Connect gretap tunnel to {{ lookup_bridge }} bridge
  command: brctl addif {{ lookup_bridge }} {{ iface_name }}
  vars:
    iface_name: gretap_{{ index_key }}_{{ hostvars[item]['index_key'] }}
  loop: "{{ groups[ansible_limit] }}"
  loop_control:
    index_var: idx
  when: >-
    inventory_hostname != item
    and gretap_bridged.results[idx].stdout == ""

- name: Create ovn_uplink_interface veth pair {{ ovn_uplink_interface }} and {{ ovn_uplink_interface }}p
  command: ip link add {{ ovn_uplink_interface }} type veth peer name {{ ovn_uplink_interface }}p
  args:
    creates: /sys/class/net/{{ ovn_uplink_interface }}
  when: vars["ansible_" + ovn_uplink_interface] is not defined

- name: Add ovn_uplink_interface {{ ovn_uplink_interface }} to {{ lookup_bridge }} bridge
  command: ip link set {{ ovn_uplink_interface }}p master {{ lookup_bridge }}

- name: Bring "{{ ovn_uplink_interface }}" interface up
  command: ip link set dev {{ ovn_uplink_interface }} up
  when: >-
    (vars["ansible_" + ovn_uplink_interface] is not defined
    or vars["ansible_" + ovn_uplink_interface].active != true)

- name: Bring "{{ ovn_uplink_interface }}p" interface up
  command: ip link set dev {{ ovn_uplink_interface }}p up
  when: >-
    (vars["ansible_" + ovn_uplink_interface] is not defined
    or vars["ansible_" + ovn_uplink_interface].active != true)

# - name: Show interface {{ ovn_uplink_interface }} information (for informational purposes only)
#   when: 
#     - vars["ansible_" + ovn_uplink_interface] is defined
#   debug:
#     msg: |-
#       f"Interface {{ ovn_uplink_interface }} is active: {{ vars['ansible_' + ovn_uplink_interface].active }}"
#   # tags: ["prerequisite"]

- name: Set preseed file location
  run_once: true
  debug:
    msg: infra-{{group_name}}/preseed.yml
  register: preseed_file

- name: add lookup_subnet to preseed.yml using private ip subnet
  delegate_to: localhost
  run_once: true
  when: inventory_hostname == ansible_play_hosts[0]
  shell: |-
    touch {{preseed_file.msg}}
    yq -i '.lookup_subnet = "{{ lookup_subnet }}"'\
      {{preseed_file.msg}}
  become: false

- name: Set ovn config
  when: ovn is defined
  run_once: true
  local_action: command yq -i --prettyPrint '.ovn = env(ovn)' {{preseed_file.msg}}
  environment:
    ovn: "{{ovn}}"
  become: false
  
# - name: Get remote hostname
#   debug:
#     msg: "{{ ansible_hostname }}"
#   register: current_remote

- name: Set microcloud system config
  delegate_to: localhost
  throttle: 1 # make it run serially per remote host
  # take the existing 'systems:' field if it exists and
  # remove any object with the same name as this current host
  # then add the details of the current host(essentally replacing)
  command: >-
    yq -i --prettyPrint 'del(.systems[] | select(.name == "{{ansible_nodename}}")) |
    .systems += [{"name": "{{ansible_nodename}}",
    "ovn_uplink_interface": "{{ovn_uplink_interface}}",
    "storage": env(host_storage)}]'
    {{preseed_file.msg}}
  vars:
    storage:
      local:
        path: '{{local_volume_path | default("")}}'
        wipe: '{{wipe_local}}'
      ceph:
        - path: '{{ceph_volume_path | default("")}}'
          wipe: '{{wipe_ceph}}'
    # current_remote: '{{current_remote}}'
  environment:
    host_storage: '{{storage}}'
  become: false



    
