---
# Add further tasks for the common role (applied to all servers) to this playbook...

- name: Gather the package facts
  package_facts:
    manager: auto
# - name: Set index based on inventory hostname
#   set_fact:
#     index: "{{ ansible_play_hosts.index(inventory_hostname) | int }}"
# - name: Generate random MAC address with prefix
#   set_fact:
#     random_mac: "{{ lookup_bridge_mac_prefix | community.general.random_mac }}"
# - name: Print the package facts
#   ansible.builtin.debug:
#     var: ansible_facts.packages
#   # tags: ["prerequisite"]
# - name: Show interface
#   debug:
#     msg: "{{ anible_facts['mcbr_bridge'] }}"
    # msg: "{{ hostvars[host]['ansible_facts']['eth1']['ipv4']['address'] }}"
# - name: Show interfaces
#   debug:
#     msg: "{{ ansible_interfaces }}"

# - name: Get loaded modules
#   register: loaded_modules
#   command: lsmod

###### Uncomment this
- name: Update package lists
  apt: update_cache=yes

- name: Install snapd package
  when: "'snapd' not in ansible_facts.packages"
  apt:
    name: snapd
    state: present

- name: Set snapd version
  # when: "'snapd' not in ansible_facts.packages"
  snap:
    name: snapd
    state: present
    channel: '{{snapd_channel}}'
  
- name: Set snapd version using command
  command: snap refresh snapd --channel={{snapd_channel}}

- name: Install core snap
  when: "'snapd' not in ansible_facts.packages"
  snap:
    name: core
    state: present
  # tags: ["prerequisite"]

- name: Install bridge-utils
  when: "'bridge-utils' not in ansible_facts.packages"
  apt:
    name: bridge-utils
    state: present

- name: Install net-tools
  when: "'net-tools' not in ansible_facts.packages"
  apt:
    name: net-tools
    state: present

- name: Install network-manager
  when: "'network-manager' not in ansible_facts.packages"
  apt:
    name: network-manager
    state: present

- name: Uninstall existing apt LXD
  # when: "'lxd' in ansible_facts.packages"
  apt:
    name: lxd
    state: absent

- name: Uninstall existing apt lxd-client
  # when: "'lxd-client' in ansible_facts.packages"
  apt:
    name: lxd-client
    state: absent

- name: Install LXD snap (channel - {{lxd_channel}})
  # when: "'lxd' not in ansible_facts.packages"
  snap:
    name: lxd
    channel: '{{lxd_channel}}'
    classic: no  # Avoid classic confinement (recommended)

- name: Install httpry
  when: "'httpry' not in ansible_facts.packages"
  apt:
    name: httpry
    state: present

- name: Install tcpflow
  when: "'tcpflow' not in ansible_facts.packages"
  apt:
    name: tcpflow
    state: present

- name: Install iputils-ping
  when: "'iputils-ping' not in ansible_facts.packages"
  apt:
    name: iputils-ping
    state: present

# - name: Disable ufw
#   when: "'ufw' in ansible_facts.packages"
#   ufw:
#     state: disabled
    # policy: allow

# - name: Allow port 8443 on lxc
#   command: lxc config set core.https_address :8443

- name: Check if secondary ip exists on eth0
  shell: |
    ip addr show eth0 | grep "inet " | awk '{print $2}' | {
        read -r ip1
        read -r ip2
        if [ -n "$ip2" ]; then
            echo "$ip2"
        fi
    }
  register: secondary_ip
# - debug:
#     msg: secondary ip - {{secondary_ip.stdout}}

- name: Delete secondary ip
  command: ip addr del {{ secondary_ip.stdout }} dev eth0
  when: secondary_ip.stdout != ""

# - name: Check if bridge already exists
#   command: |
#     lxc network show {{ lookup_bridge }}
#   register: bridge_check
#   ignore_errors: true

- name: Create lxc bridge interface {{ lookup_bridge }}
  when: vars["ansible_" + lookup_bridge] is not defined
  # when: bridge_check.rc != 0
  command: >-
    lxc network create {{ lookup_bridge }}
    ipv4.address={{ lookup_subnet |
    ansible.utils.next_nth_usable(host_index | int) }}/{{ bridge_netmask }}
  # ipv4.nat=true
  # ipv6.nat=true
  args:
    creates: /sys/class/net/{{ lookup_bridge }}
  vars:
    bridge_netmask: "{{ lookup_subnet | ansible.utils.ipaddr('prefix')}}"
    host_index: "{{ index_key }}"

- name: Disable firewall on lxc bridge interface {{ lookup_bridge }}
  shell: |
    lxc network set {{ lookup_bridge }} ipv6.firewall false
    lxc network set {{ lookup_bridge }} ipv4.firewall false

- name: Configure ufw allow for lxc bridge interface {{ lookup_bridge }}
  when: "'ufw' in ansible_facts.packages"
  shell: |
    ufw allow in on {{ lookup_bridge }}
    ufw route allow in on {{ lookup_bridge }}
    ufw route allow out on {{ lookup_bridge }}

- name: Create vxlan gre tunnels (all-to-all)
    # lxc network set {{ lookup_bridge }} bridge.hwaddr {{random_mac}}
  shell: |-
    lxc network set {{ lookup_bridge }} tunnel.{{peer_grename | sort | join()}}.protocol vxlan
    lxc network set {{ lookup_bridge }} tunnel.{{peer_grename | sort | join()}}.id {{peer_grename | sort | join()}}
    lxc network set {{ lookup_bridge }} tunnel.{{peer_grename | sort | join()}}.interface {{ipv4_address_iface}}
    # lxc network set {{ lookup_bridge }} tunnel.{{peer_grename | sort | join()}}.port 4789
    lxc network set {{ lookup_bridge }} tunnel.{{peer_grename | sort | join()}}.local {{ ipv4_address_private }}
    lxc network set {{ lookup_bridge }} tunnel.{{peer_grename | sort | join()}}.remote {{ hostvars[item]['ipv4_address_private'] }}
  vars:
    iface_id: "1{{ index_key }}{{ hostvars[item]['index_key'] }}"
    peer_hostname: "{{hostvars[item]['ansible_nodename']}}"
    peer_grename: "1{{ index_key }}{{ hostvars[item]['index_key'] }}"
    # random_mac: "{{ lookup_bridge_mac_prefix | community.general.random_mac }}"
  args:
    creates: /sys/class/net/{{ lookup_bridge }}-{{ peer_grename }}
  loop: "{{ groups[ansible_limit] }}"
  when: inventory_hostname != item and vars["ansible_" + lookup_bridge + "-" + peer_grename] is not defined
  #   vars["ansible_" + iface_name] is not defined
  #   and inventory_hostname != item


- name: Ping test all-to-all network connectivity
  command: |-
    ping -c 2 {{ lookup_subnet | ansible.utils.next_nth_usable(host_index | int) }}
  vars:
    host_index: "{{ hostvars[item]['index_key'] }}"
  loop: "{{ groups[ansible_limit] }}"
  # when: inventory_hostname != item
  register: ping_results
  retries: 3
  delay: 3
  until: ping_results.rc == 0

# - name: Test that ping tests passed
#   fail:
#     msg: "Ping test failed: {{item.stdout_lines}}"
#   when: item.rc != 0
#   loop: "{{ping_results.results}}"

- name: Create ovn_uplink_interface 
  command: >-
    lxc network create {{ ovn_uplink_interface }}
  args:
    creates: /sys/class/net/{{ ovn_uplink_interface }}
  when: vars["ansible_" + ovn_uplink_interface] is not defined

# - name: Show interface {{ ovn_uplink_interface }} information (for informational purposes only)
#   when: 
#     - vars["ansible_" + ovn_uplink_interface] is defined
#   debug:
#     msg: |-
#       f"Interface {{ ovn_uplink_interface }} is active: {{ vars['ansible_' + ovn_uplink_interface].active }}"
#   # tags: ["prerequisite"]

- name: Set preseed file location
  run_once: true
  debug:
    msg: infra-{{ansible_limit}}/preseed.yml
  register: preseed_file

- name: add lookup_subnet and interface to preseed.yml using private ip subnet
  delegate_to: localhost
  run_once: true
  when: inventory_hostname == ansible_play_hosts[0]
  shell: |-
    touch {{preseed_file.msg}}
    yq -i '.lookup_subnet = "{{ lookup_subnet | ansible.utils.next_nth_usable(host_index | int) }}/{{ bridge_netmask }}" |
    .lookup_interface = "{{ lookup_bridge }}"' {{preseed_file.msg}}
  become: false
    # yq -i '.lookup_subnet = "{{ lookup_subnet | ansible.utils.next_nth_usable(host_index | int) }}/{{ bridge_netmask }}" |
    # yq -i '.lookup_subnet = "{{ ipv4_address_private_cidr }}" |
  vars:
    bridge_netmask: "{{ lookup_subnet | ansible.utils.ipaddr('prefix')}}"
    host_index: "{{ hostvars[inventory_hostname]['index_key'] }}"

- name: Set ovn config
  when: ovn is defined
  run_once: true
  local_action: command yq -i --prettyPrint '.ovn = env(ovn)' {{preseed_file.msg}}
  environment:
    ovn: "{{ovn}}"
  become: false

- name: Remove ovn config
  when: ovn is not defined
  run_once: true
  local_action: command yq -i --prettyPrint 'del(.ovn)' {{preseed_file.msg}}
  become: false
  
# - name: Get remote hostname
#   debug:
#     msg: "{{ ansible_hostname }}"
#   register: current_remote

- name: Set microcloud system config
  delegate_to: localhost
  throttle: 1 # make it run serially per remote host
  # take the existing 'systems:' field if it exists and
  # remove any object with the same name as this current host
  # then add the details of the current host(essentally replacing)
  command: >-
    yq -i --prettyPrint 'del(.systems[] | select(.name == "{{ansible_nodename}}")) |
    .systems += [{"name": "{{ansible_nodename}}",
    "ovn_uplink_interface": "{{lookup_bridge}}",
    "storage": env(host_storage)}]'
    {{preseed_file.msg}}
  vars:
    storage:
      local:
        path: '{{local_volume_path | default("")}}'
        wipe: '{{wipe_local}}'
      ceph:
        - path: '{{ceph_volume_path | default("")}}'
          wipe: '{{wipe_ceph}}'
    # current_remote: '{{current_remote}}'
  environment:
    host_storage: '{{storage}}'
  become: false

- name: Remove empty entries from preseed
  delegate_to: localhost
  command: >-
    yq --inplace 'with(.systems.[];
      (select(.storage.local.path == "")) |= del(.storage.local) |
      (select(.storage.ceph[]?.path == "")) |= del(.storage.ceph)|
      del(.. | select(tag == "!!map" and length == 0)))'
    {{preseed_file.msg}}
  become: false



    
